# Customize LS colors: https://github.com/eza-community/eza/blob/main/man/eza_colors.5.md
# Used by: ls, exa, fd
export LS_COLORS='di=34:ln=1;34:so=33:pi=33:ex=1;36:bd=34;46:cd=34;43:su=30;41:sg=30;46:tw=30;42:ow=30;43'
export LS_COLORS="da=37:uu=37;1:un=37:gu=37;1:gn=37:sb=33:sn=33;1:$LS_COLORS"
export LS_COLORS="ur=37:uw=37:ux=37;1:ue=37;1:$LS_COLORS" # user file permissions
export LS_COLORS="gr=37:gw=37:gx=37;1:$LS_COLORS" # group file permissions
export LS_COLORS="tr=37:tw=37:tx=37;1:$LS_COLORS" # world file permissions

export EXA_COLORS='da=1;34:gm=1;34'

alias ls='eza --group-directories-first'

if eza --git /dev/null &>/dev/null; then
  alias ll='ls -l --git'      # Long format, git status
else
  alias ll='ls -l'            # Long format
fi

alias l='ll -a'               # Long format, all files
alias lr='ll -T'              # Long format, recursive as a tree
alias lx='ll -sextension'     # Long format, sort by extension
alias lk='ll -ssize'          # Long format, largest file size last
alias lt='ll -smodified'      # Long format, newest modification time last
alias lc='ll -schanged'       # Long format, newest status change (ctime) last

# Navigation Aliases
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'

# File Operation Aliases
alias cp='cp -iv'
alias mv='mv -iv'
alias rm='rm -iv'
alias mkdir='mkdir -p'
alias grep='rg'
alias egrep='egrep --color=always'
alias cdiff='delta'

# Viewing/Editing Aliases
alias cat='bat'
alias less='bat'
alias vi='nvim'
alias vim='nvim'
alias svi='sudo nvim'
alias view='nvim -R'

# Tmux
alias t='tmux'
alias ta='t a -t'
alias tn='t new -t'

# Network Aliases
alias ping='ping -c 10'
alias ss='ss -lntu'
alias ltcp='lsof -n -i -P | grep -i TCP'
alias lisn='lsof -n -i -P | grep -i LISTEN'
alias lssh='lsof -n -i -P | grep -i ":22"'
alias tdump='tcpdump -i eth1 "port 8080"'
alias tdumpv='tcpdump -vv -x -X -s 1500 -i eth1 "port 8080"'

alias pbcopy='gcopy'

# Misc Functions
whoip() {
  curl ip-api.com/$1
}

urldecode() {
  echo $1 | python3 -c "import sys; from urllib.parse import unquote; print(unquote(sys.stdin.read()));"
}

grsub() {
  if [ -z "$1" ]; then
    echo "Please provide a submodule path/name"
  else
    git submodule deinit -f -- $1
    rm -rf .git/modules/$1
    git rm -f $1
  fi
}

bak() {
  LOGDATE=$(date +%Y%m%dT%H%M%S)
  cp "$1" "$1.bak.$LOGDATE"
}

# fshow - git commit browser (enter for show, ctrl-d for diff, ` toggles sort)
fshow() {
  local out shas sha q k
  while out=$(
    git log --graph --color=always \
      --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" "$@" |
      fzf --ansi --multi --no-sort --reverse --query="$q" --tiebreak=index \
        --print-query --expect=ctrl-d --toggle-sort=\`
  ); do
    q=$(head -1 <<<"$out")
    k=$(head -2 <<<"$out" | tail -1)
    shas=$(sed '1,2d;s/^[^a-z0-9]*//;/^$/d' <<<"$out" | awk '{print $1}')
    [ -z "$shas" ] && continue
    if [ "$k" = 'ctrl-d' ]; then
      git diff --color=always $shas | less -R
    else
      for sha in $shas; do
        git show --color=always $sha | less -R
      done
    fi
  done
}

# Kubernetes Aliases
debug_daemonset() {
  RED="31m"
  GREEN="32m"
  BOLD_RED="\e[1;${RED}"
  BOLD_GREEN="\e[1;${GREEN}"
  ENDCOLOR="\e[0m"
  if [ -z "$1" ]; then
    echo "Please provide a Daemonset pod name string value"
  else
    daemonsetName=$1
    daemonsetString="$daemonsetName-[^-]+$"
    echo "Checking for Daemonset pods with string: $daemonsetString"
    for node in $(kubectl get nodes --no-headers | awk '{print $1}'); do
      if kubectl get pods --all-namespaces -o wide --field-selector spec.nodeName="$node" --no-headers | awk '{print $2}' | grep -Eq "$daemonsetString"; then
        echo -e "${BOLD_GREEN}Found daemonset pod on: $node${ENDCOLOR}"
      else
        echo -e "${BOLD_RED}Missing daemonset pod on: $node${ENDCOLOR}"
      fi
    done
  fi
}

find_istio_proxy() {
  RED="31m"
  GREEN="32m"
  BOLD_RED="\e[1;${RED}"
  BOLD_GREEN="\e[1;${GREEN}"
  ENDCOLOR="\e[0m"
  echo "Checking pods for istio proxy"
  for pod in $(kubectl get pods --no-headers | awk '{print $1}'); do
    if kubectl get pod "$pod" -o jsonpath="{.spec.containers[*].name}" | tr -s '[:space:]' '\n' | grep -q "istio-proxy"; then
      istioVersion=$(kubectl get pod "$pod" -o jsonpath="{.spec.containers[*].image}" | tr -s '[:space:]' '\n' | grep "istio" | cut -d ":" -f2)
      echo -e "${BOLD_GREEN}$pod has istio-proxy injected using version: $istioVersion${ENDCOLOR}"
    else
      echo -e "${BOLD_RED}$pod is missing istio-proxy${ENDCOLOR}"
    fi
  done
}

alias kgn="kubectl get nodes -o wide"
alias kgp="kubectl get pods -o wide"
alias kgd="kubectl get deployment -o wide"
alias kgs="kubectl get svc -o wide"
alias kdp="kubectl describe pod"
alias kdd="kubectl desribe deployment"
alias kds="kubectl describe service"
alias kdn="kubectl describe node"

# Get All Non-Running Pods
kpnr() {
  kubectl get pods -A --field-selector=status.phase!=Running | grep -v "Complete"
}
# Get list of nodes and their memory size
knmem() {
  kubectl get no -o json | jq -r '.items | sort_by(.status.capacity.memory)[] | [.metadata.name,.status.capacity.memory] | @tsv'
}
# Get list of nodes and the number of pods running on them
knpc() {
  kubectl get po -o json --all-namespaces | jq '.items | group_by(.spec.nodeName) | map({"nodeName": .[0].spec.nodeName, "count": length}) | sort_by(.count)'
}
# Get top pods based on cpu
kptc() {
  kubectl top pods -A | sort --reverse --key 3 --numeric
}
# Get top pods based on mem
kptm() {
  kubectl top pods -A | sort --reverse --key 4 --numeric
}
# Print limits and requests for pods
kplr() {
  kubectl get pods -A -o=custom-columns='NAME:spec.containers[*].name,MEMREQ:spec.containers[*].resources.requests.memory,MEMLIM:spec.containers[*].resources.limits.memory,CPUREQ:spec.containers[*].resources.requests.cpu,CPULIM:spec.containers[*].resources.limits.cpu'
}
# Get internal IP addresses of cluster nodes
knip() {
  kubectl get nodes -o json | jq -r '.items[].status.addresses[]? | select (.type == "InternalIP") | .address' | paste -sd "\n" -
}
# Get all unique container images across cluster
kgca() {
  kubectl get pods --all-namespaces -o jsonpath="{.items[*].spec.containers[*].image}" | tr -s '[[:space:]]' '\n' | sort | uniq -c
}

docker() {
  # Determine if containerd or docker is running
  evalCmd=$(nerdctl info &>/dev/null && echo nerdctl || echo docker)
  cntrCmd=("$evalCmd")
  for var in "$@"
  do
    # strip docker from command
    if [[ $var == "docker" ]]; then
      continue
    fi
    # add each argument to the array
    cntrCmd+=("$var")
  done

  # execute the command with the arguments
  command "${cntrCmd[@]}"
}

kdebug() {
  POD=$1
  kubectl debug -it $POD --image=730998372749.dkr.ecr.us-west-2.amazonaws.com/debug:debian --image-pull-policy='Always' --profile=netadmin
}

kdrun() {
  POD=ephemeral-debug-$(date -u +"%Y-%m-%dt%H-%M-%Sz")
  kubectl run $POD --image=730998372749.dkr.ecr.us-west-2.amazonaws.com/debug:debian --restart=Never --attach=true --image-pull-policy=Always --tty=true --privileged=true --rm=true --stdin=true --port=8080 -- /bin/bash
}

awsprof() {
  if [ -z "$1" ]; then
    export AWS_PROFILE="$(perl -nle '/\[profile (.+)\]/ && print "$1"' < "$HOME/.aws/config" | fzf)"
  else
    export AWS_PROFILE="$1"
  fi
}

esanno() {
  SECRET=$1
  kubectl annotate es $SECRET force-sync=$(date +%s) --overwrite
}

hbuild() {
  helm template base .
}

htest() {
  helm template base . | kubeconform -schema-location default -schema-location 'https://raw.githubusercontent.com/datreeio/CRDs-catalog/main/{{.Group}}/{{.ResourceKind}}_{{.ResourceAPIVersion}}.json' -strict -verbose
}

kgfj() {
  kubectl get job --all-namespaces -o=jsonpath='{range .items[?(@.status.failed==1)]}{.metadata.namespace} {.metadata.name}{"\n"}{end}' | xargs -n 2 kubectl get job -n
}

kdfj() {
  kubectl get job --all-namespaces -o=jsonpath='{range .items[?(@.status.failed==1)]}{.metadata.namespace} {.metadata.name}{"\n"}{end}' | xargs -n 2 kubectl delete job -n
}

tf () {
	if [ -f terragrunt.hcl ]
	then
		terragrunt "$@"
	else
		terraform "$@"
	fi
}

git-check-ignore(){
  FILE_PATH=$1
  git check-ignore -v "$FILE_PATH"
}

tffmt () {
	terraform fmt -recursive && tf_vars_sort **/{outputs,variables}.tf(N) && terragrunt hclfmt
}

flushdns(){
  sudo dscacheutil -flushcache && sudo killall -HUP mDNSResponder

cat << EOF
Google Chrome:

    Open Chrome and type "chrome://net-internals/#dns" into the address bar.
    Press Enter to access the DNS page.
    Click on the "Clear host cache" button to clear the resolver cache.

Microsoft Edge (Chromium-based):

    Launch Edge and type "edge://net-internals/#dns" in the address bar.
    Press Enter to go to the DNS page.
    Click on the "Clear host cache" button to clear the resolver cache.

Mozilla Firefox:

    Open Firefox and type "about:networking#dns" in the address bar.
    Press Enter to access the DNS page.
    Click on the "Clear DNS Cache" button to clear the resolver cache.

Opera:

    Launch Opera and type "opera://net-internals/#dns" in the address bar.
    Press Enter to go to the DNS page.
    Click on the "Clear host cache" button to clear the resolver cache.
EOF
}

start-grafana() {
  /opt/homebrew/opt/grafana/bin/grafana server --config /opt/homebrew/etc/grafana/grafana.ini --homepath /opt/homebrew/opt/grafana/share/grafana --packaging\=brew cfg:default.paths.logs\=/opt/homebrew/var/log/grafana cfg:default.paths.data\=/opt/homebrew/var/lib/grafana cfg:default.paths.plugins\=/opt/homebrew/var/lib/grafana/plugins
}

jira() {
  # launch in a (subshell) so the api token doesn't linger in env after running
  (export JIRA_API_TOKEN=$(cat ~/.netrc | grep --color=none password | awk '{print $2}') && command jira $@)
}

ukctx() {
  kubectl config unset current-context
}

ktn() {
  kubectl drain --ignore-daemonsets --delete-emptydir-data $1
}

oldman() {
  # source: https://media3.giphy.com/media/LvtKS6f1WatQ4/giphy-downsized.gif?cid=6104955ev42b150we7z0cd8shnoeh02cyopzgojz3uwzy5bn&ep=v1_gifs_translate&rid=giphy-downsized.gif&ct=g
  echo "https://tinyurl.com/3e63z8dz" | pbcopy
}

brewls() {
  # https://apple.stackexchange.com/a/438632
  brew info --json=v2 --installed | jq -r '.formulae[]|select(any(.installed[]; .installed_on_request)).full_name'
}

function yy() {
  local tmp="$(mktemp -t "yazi-cwd.XXXXXX")"
  yazi "$@" --cwd-file="$tmp"
  if cwd="$(cat -- "$tmp")" && [ -n "$cwd" ] && [ "$cwd" != "$PWD" ]; then
      cd -- "$cwd"
  fi
  rm -f -- "$tmp"
}
